{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#jinja-psycopg","title":"Jinja-Psycopg","text":"<p>Jinja-Psycopg is a bridge between the jinja templating engine and psycopg3's type-aware formatting.</p> <p> </p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from jinja_psycopg import JinjaPsycopg\nfrom psycopg.sql import Identifier\nquery = \"\"\"\\\n{% set sep = joiner('\\nAND ') -%}\nSELECT * FROM {{ table }}\nWHERE\n{% for column, value in where %}\n{{- sep() | sql -}}\n{{ column }} = {{ value }}\n{%- endfor %};\n\"\"\"\nrenderer = JinjaPsycopg()\nrenderer.render(\nquery,\n{\n\"table\": Identifier(\"people\"),\n\"where\": [\n(Identifier(\"name\"), \"Simon\"),\n(Identifier(\"year\"), 2015),\n(Identifier(\"subject\"), Placeholder(\"subject\")),\n],\n},\n)\n</code></pre> <p>This script renders the following SQL.</p> <p>Strings will be automatically escaped, Identifiers quoted and Placeholders wrapped with the placeholder syntax</p> <pre><code>SELECT * FROM \"people\"\nWHERE\n\"name\" = 'Simon'\nAND \"year\" = 2015\nAND \"subject\" = %(subject)s;\n</code></pre>"},{"location":"#the-composed-object","title":"The Composed object","text":"<p>Ok, that's not the whole story.</p> <p>The render() method returns a psycopg.sql.Composed, which needs to be turned into a string by the backend:</p> <pre><code>psycopg.connect(\"dbame=test\") as conn:\n# Render to string\nprint(composed.as_string(conn))\n# Or execute directly\nconn.execute(composed, {\"subject\": \"Math\"})\n</code></pre>"},{"location":"#sqltemplate-and-sqltemplatemodule","title":"SqlTemplate and SqlTemplateModule","text":"<p>Like in jinja, you can save your templates</p> <pre><code>template = renderer.from_string(\n\"\"\"\\\n    {% set config = { 'option': True } %}\n    select field from {{ table }};\"\"\"\n)\n</code></pre> <p>And turn them into python modules</p> <pre><code>module = template.make_module({ \"table\": Identifier(\"foo\") })\nassert getattr(sqlmodule.module, \"config\")['option'] == True\n# Render to SQL\ncomposed = sqlmodule.render()\n</code></pre>"},{"location":"#custom-sql-objects","title":"Custom SQL Objects","text":"<pre><code>@dataclass\nclass Table:\nschema: str\nname: str\ndef __sql__(self):\nreturn Identifier(self.name, self.schema)\nrenderer.render(\n\"select * from {{ table }}\",\n{\"table\": Table(\"public\", \"foo\")}\n)\n</code></pre>"},{"location":"#custom-environments","title":"Custom Environments","text":"<p>To add your own global variables and filters to the jinja Environment, you can subclass JinjaPsycopg</p> <pre><code>class CustomRenderer(JinjaPsycopg):\ndef _prepare_environment(self):\nsuper()._prepare_environment()\nself._env.globals[\"foo\"] = my_global_variable\nself._env.filters[\"bar\"] = my_filter\n</code></pre>"},{"location":"#filters","title":"Filters","text":""},{"location":"#psycopg","title":"psycopg","text":"<p>This filter is applied automatically to all jinja blocks:</p> <p><code>{{ value }}</code> is equivalent to <code>{{ (value) | psycopg }}</code></p> <p>It stores the actual value inside a ContextVar, replacing <code>{{value}}</code> with a placeholder like <code>{dictionary_key}</code> to later be passed to SQL.format</p>"},{"location":"#sql","title":"sql","text":"<p>Treat a string value as plain SQL, not as a literal</p> <p><code>ALTER TABLE foo {{ 'ADD COLUMN html TEXT' | sql }}</code></p>"},{"location":"#sqljoin","title":"sqljoin","text":"<p>Same as jinja's join filter, but operates on SQL objects</p> <p><code>{{ [Identifier(\"foo\"), Identifier(\"bar\")] | sqljoin(',') }}</code></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>jinja_psycopg<ul> <li>context</li> <li>extension</li> <li>renderer</li> <li>sql</li> </ul> </li> </ul>"},{"location":"reference/jinja_psycopg/__init__/","title":"init","text":"<p>Re-exports classes from .renderer</p>"},{"location":"reference/jinja_psycopg/context/","title":"context","text":""},{"location":"reference/jinja_psycopg/context/#jinja_psycopg.context.FormatArgs","title":"<code>FormatArgs(prefix)</code>","text":"<p>Data structure for recording values in jinja blocks to be formatted by psycopg</p> <p>Parameters:</p> <ul> <li> prefix             (<code>str</code>)         \u2013          <p>Prefix used in dictionary keys</p> </li> </ul> Source code in <code>jinja_psycopg/context.py</code> <pre><code>def __init__(self, prefix: str) -&gt; None:\n\"\"\"Data structure for recording values in jinja blocks to be formatted by psycopg\n    Args:\n        prefix: Prefix used in dictionary keys\n    \"\"\"\nself._prefix = prefix\nself._dictionary = {}\nself._num_values = 0\n</code></pre>"},{"location":"reference/jinja_psycopg/context/#jinja_psycopg.context.FormatArgs.dictionary","title":"<code>dictionary: dict</code>  <code>property</code>","text":"<p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>saved values</p> </li> </ul>"},{"location":"reference/jinja_psycopg/context/#jinja_psycopg.context.FormatArgs.save_value","title":"<code>save_value(value)</code>","text":"<p>Parameters:</p> <ul> <li> value             (<code>Any</code>)         \u2013          <p>value to save</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>generated key in the format of <code>prefix#number</code></p> </li> </ul> Source code in <code>jinja_psycopg/context.py</code> <pre><code>def save_value(self, value: Any) -&gt; str:\n\"\"\"\n    Args:\n        value: value to save\n    Returns:\n        generated key in the format of `prefix#number`\n    \"\"\"\nkey = f\"{self._prefix}#{self._num_values}\"\nself._dictionary[key] = value\nself._num_values += 1\nreturn key\n</code></pre>"},{"location":"reference/jinja_psycopg/context/#jinja_psycopg.context.FormatArgsContext","title":"<code>FormatArgsContext(name)</code>","text":"<p>Wrapper for contextvars.ContextVar used for saving format args from within     <code>psycopg</code> filter and for creating argument recorders</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>name used by the ContextVar</p> </li> </ul> Source code in <code>jinja_psycopg/context.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n\"\"\"Wrapper for [contextvars.ContextVar][] used for saving format args from within\n        [`psycopg`][jinja_psycopg.renderer.psycopg_filter] filter and for creating argument recorders\n    Args:\n        name: name used by the ContextVar\n    \"\"\"\nself._context_var = ContextVar[Optional[FormatArgs]](name, default=None)\n</code></pre>"},{"location":"reference/jinja_psycopg/context/#jinja_psycopg.context.FormatArgsContext.save_value","title":"<code>save_value(value)</code>","text":"<p>Parameters:</p> <ul> <li> value             (<code>Any</code>)         \u2013          <p>value to save</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>generated key in the format of <code>prefix#number</code></p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013          <p>if ContextVar was empty</p> </li> </ul> Source code in <code>jinja_psycopg/context.py</code> <pre><code>def save_value(self, value: Any) -&gt; str:\n\"\"\"\n    Args:\n        value: value to save\n    Returns:\n        generated key in the format of `prefix#number`\n    Raises:\n        RuntimeError: if ContextVar was empty\n    \"\"\"\ncontext = self._context_var.get()\nif context is None:\nraise RuntimeError(\n\"Called ContextWriter.save_value, but no context was found\"\n)\nreturn context.save_value(value)\n</code></pre>"},{"location":"reference/jinja_psycopg/context/#jinja_psycopg.context.FormatArgsContext.recorder","title":"<code>recorder(prefix)</code>","text":"<p>Parameters:</p> <ul> <li> prefix             (<code>str</code>)         \u2013          <p>Prefix for the keys in the resulting dictionary</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FormatArgsRecorder</code>         \u2013          <p>new recorder with the given prefix</p> </li> </ul> Source code in <code>jinja_psycopg/context.py</code> <pre><code>def recorder(self, prefix: str) -&gt; FormatArgsRecorder:\n\"\"\"\n    Args:\n        prefix: Prefix for the keys in the resulting dictionary\n    Returns:\n        new recorder with the given prefix\n    \"\"\"\nreturn FormatArgsRecorder(self._context_var, prefix)\n</code></pre>"},{"location":"reference/jinja_psycopg/context/#jinja_psycopg.context.FormatArgsRecorder","title":"<code>FormatArgsRecorder(context_var, prefix)</code>","text":"<p>contextvars.ContextVar wrapper that works as a context manager and records arguments saved within its scope into a dictionary</p> <p>Parameters:</p> <ul> <li> context_var             (<code>ContextVar[Optional[FormatArgs]]</code>)         \u2013          <p>Inner ContextVar</p> </li> <li> prefix             (<code>str</code>)         \u2013          <p>Prefix used in dictionary keys</p> </li> </ul> Source code in <code>jinja_psycopg/context.py</code> <pre><code>def __init__(\nself, context_var: ContextVar[Optional[FormatArgs]], prefix: str\n) -&gt; None:\n\"\"\"[contextvars.ContextVar][] wrapper that works as a context manager\n    and records arguments saved within its scope into a dictionary\n    Args:\n        context_var: Inner ContextVar\n        prefix: Prefix used in dictionary keys\n    \"\"\"\nself._context_var = context_var\nself._prefix = prefix\nself._recorded = None\n</code></pre>"},{"location":"reference/jinja_psycopg/context/#jinja_psycopg.context.FormatArgsRecorder.unwrap","title":"<code>unwrap()</code>","text":"<p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>the recorded arguments</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013          <p>if nothing was recorded</p> </li> </ul> Source code in <code>jinja_psycopg/context.py</code> <pre><code>def unwrap(self) -&gt; dict[str, Any]:\n\"\"\"\n    Returns:\n        the recorded arguments\n    Raises:\n        RuntimeError: if nothing was recorded\n    \"\"\"\nif self._recorded is None:\nraise RuntimeError(\n\"Called ContextDictRecorder.unwrap(), but nothing was recorded\"\n)\nreturn self._recorded\n</code></pre>"},{"location":"reference/jinja_psycopg/extension/","title":"extension","text":""},{"location":"reference/jinja_psycopg/extension/#jinja_psycopg.extension.PsycopgExtension","title":"<code>PsycopgExtension</code>","text":"<p>             Bases: <code>Extension</code></p> <p>Wraps all expressions with the <code>psycopg</code> filter,</p> <p>so <code>{{ variable | filter1 | filter2 }}</code></p> <p>becomes <code>{{ (variable | filter1 | filter2) | psycopg }}</code></p> <p>Inspired by jinjasql</p>"},{"location":"reference/jinja_psycopg/renderer/","title":"renderer","text":""},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.SqlTemplate","title":"<code>SqlTemplate(template, static_args)</code>","text":"<p>Wrapper for jinja2.Template that stores static format arguments     such as <code>{{ 'text' }}</code></p> <p>Parameters:</p> <ul> <li> template             (<code>Template</code>)         \u2013          <p>inner Template</p> </li> <li> static_args             (<code>dict[str, Any]</code>)         \u2013          <p>args recurded during template creation</p> </li> </ul> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def __init__(self, template: Template, static_args: dict[str, Any]) -&gt; None:\n\"\"\"Wrapper for [jinja2.Template][] that stores static format arguments\n        such as `{{ 'text' }}`\n    Args:\n        template: inner Template\n        static_args: args recurded during template creation\n    \"\"\"\nself._template = template\nself._static_args = static_args\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.SqlTemplate.render","title":"<code>render(*args, **kwargs)</code>","text":"<p>Same as jinja2.Template.render, but returns a psycopg.sql.Composed object</p> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def render(self, *args, **kwargs) -&gt; Composed:\n\"\"\"\n    Same as [jinja2.Template.render][], but returns a [psycopg.sql.Composed][] object\n    \"\"\"\nrecorder = CONTEXT.recorder(\"dynamic\")\nwith recorder:\nsql = SQL(self._template.render(*args, **kwargs))\ndynamic_args = recorder.unwrap()\ncomposed = sql.format(**self._static_args, **dynamic_args)\nreturn escape_percents(composed)\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.SqlTemplate.make_module","title":"<code>make_module(vars=None, shared=False, locals=None)</code>","text":"<p>Same as jinja2.Template.make_module, but returns a wrapper that remembers all the format arguments</p> <p>Returns:</p> <ul> <li> <code>SqlTemplateModule</code>         \u2013          <p>module wrapper</p> </li> </ul> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def make_module(\nself,\nvars: Optional[dict[str, Any]] = None,\nshared: bool = False,\nlocals: Optional[Mapping[str, Any]] = None,\n) -&gt; SqlTemplateModule:\n\"\"\"\n    Same as [jinja2.Template.make_module][], but returns a wrapper that remembers all the format arguments\n    Returns:\n        module wrapper\n    \"\"\"\nrecorder = CONTEXT.recorder(\"dynamic\")\nwith recorder:\nmodule = self._template.make_module(vars, shared, locals)\ndynamic_args = recorder.unwrap()\nreturn SqlTemplateModule(module, {**self._static_args, **dynamic_args})\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.SqlTemplateModule","title":"<code>SqlTemplateModule(module, args)</code>","text":"<p>Wrapper over jinja2.environment.TemplateModule that stores all the format arguments for use in SQL.format</p> <p>Parameters:</p> <ul> <li> module             (<code>TemplateModule</code>)         \u2013          <p>inner module</p> </li> <li> args             (<code>dict[str, Any]</code>)         \u2013          <p>args recorded during module creation</p> </li> </ul> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def __init__(self, module: TemplateModule, args: dict[str, Any]) -&gt; None:\n\"\"\"Wrapper over jinja2.environment.TemplateModule that stores all the format arguments\n    for use in [SQL.format][psycopg.sql.SQL.format]\n    Args:\n        module: inner module\n        args: args recorded during module creation\n    \"\"\"\nself._module = module\nself._args = args\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.SqlTemplateModule.inner","title":"<code>inner: TemplateModule</code>  <code>property</code>","text":"<p>Get inner module</p>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.SqlTemplateModule.render","title":"<code>render()</code>","text":"<p>Returns:</p> <ul> <li> <code>Composed</code>         \u2013          <p>a formatted SQL statement</p> </li> </ul> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def render(self) -&gt; Composed:\n\"\"\"\n    Returns:\n        a formatted SQL statement\n    \"\"\"\ncomposed = SQL(str(self._module)).format(**self._args)\nreturn escape_percents(composed)\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.SqlTemplateModule.getattr","title":"<code>getattr(name, default=_NO_VALUE)</code>","text":"<p>Get attribute of the inner module</p> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def getattr(self, name: str, default: Any = _NO_VALUE) -&gt; Any:\n\"\"\"Get attribute of the inner module\"\"\"\nif default is _NO_VALUE:\nreturn getattr(self._module, name)\nelse:\nreturn getattr(self._module, name, default)\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.JinjaPsycopg","title":"<code>JinjaPsycopg(env=None)</code>","text":"<p>Wrapper over jinja2.Environment that generates <code>SqlTemplate</code>s</p> <p>Parameters:</p> <ul> <li> env             (<code>Optional[Environment]</code>, default:                 <code>None</code> )         \u2013          <p>base jinja environment</p> </li> </ul> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def __init__(self, env: Optional[Environment] = None) -&gt; None:\n\"\"\"Wrapper over [jinja2.Environment][] that generates `SqlTemplate`s\n    Args:\n        env: base jinja environment\n    \"\"\"\nself._env = env or Environment()\nself._prepare_environment()\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.JinjaPsycopg.from_string","title":"<code>from_string(source, dedent=True, strip=True)</code>","text":"<p>Parameters:</p> <ul> <li> source             (<code>str</code>)         \u2013          <p>template string</p> </li> <li> dedent             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>remove indentation from source</p> </li> <li> strip             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>remove leading and trailing spaces</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SqlTemplate</code>         \u2013          <p>parsed template</p> </li> </ul> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def from_string(\nself, source: str, dedent: bool = True, strip: bool = True\n) -&gt; SqlTemplate:\n\"\"\"\n    Args:\n        source: template string\n        dedent: remove indentation from source\n        strip: remove leading and trailing spaces\n    Returns:\n        parsed template\n    \"\"\"\n# Jinja2 processes its blocks in two iterations:\n# static values like {{ 'text' }} are processed during from_string,\n# and dynamic ones during Template.render or make_module\nif dedent:\nsource = textwrap.dedent(source)\nif strip:\nsource = source.strip()\nrecorder = CONTEXT.recorder(\"static\")\nwith recorder:\ntemplate = self._env.from_string(source)\nreturn SqlTemplate(template, recorder.unwrap())\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.JinjaPsycopg.render","title":"<code>render(template, params={}, dedent=True, strip=True)</code>","text":"<p>Shorthand for rendering a template or template string</p> <p>Parameters:</p> <ul> <li> template             (<code>Union[str, SqlTemplate]</code>)         \u2013          <p>template or template string</p> </li> <li> params             (<code>dict[str, Any]</code>, default:                 <code>{}</code> )         \u2013          <p>template arguments</p> </li> <li> dedent             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>remove indentation from template string</p> </li> <li> strip             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>remove leading and trailing spaces</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Composed</code>         \u2013          <p>rendered SQL</p> </li> </ul> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def render(\nself,\ntemplate: Union[str, SqlTemplate],\nparams: dict[str, Any] = {},\ndedent: bool = True,\nstrip: bool = True,\n) -&gt; Composed:\n\"\"\"Shorthand for rendering a template or template string\n    Args:\n        template: template or template string\n        params: template arguments\n        dedent: remove indentation from template string\n        strip: remove leading and trailing spaces\n    Returns:\n        rendered SQL\n    \"\"\"\nif isinstance(template, str):\ntemplate = self.from_string(template, dedent=dedent, strip=strip)\nreturn template.render(params)\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.psycopg_filter","title":"<code>psycopg_filter(value)</code>","text":"<p>Jinja filter that saves the value inside a dictionary in ContextVar     and returns a psycopg format placeholder</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>)         \u2013          <p>value piped into the filter</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>psycopg format placeholder such as <code>{key}</code></p> </li> </ul> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def psycopg_filter(value: Any) -&gt; str:\n\"\"\"Jinja filter that saves the value inside a dictionary in ContextVar\n        and returns a psycopg format placeholder\n    Args:\n        value: value piped into the filter\n    Returns:\n        psycopg format placeholder such as `{key}`\n    \"\"\"\nif isinstance(value, IntoSql):\nvalue = value.__sql__()\nif isinstance(value, SQL):\n# No need to pass SQL to psycopg's formatter,\n# since it's included as is\nreturn value.as_string(None)\nkey = CONTEXT.save_value(value)\nreturn f\"{{{key}}}\"\n</code></pre>"},{"location":"reference/jinja_psycopg/renderer/#jinja_psycopg.renderer.escape_percents","title":"<code>escape_percents(composed)</code>","text":"<p>Replace all occurences of '%' with '%%', so that psycopg doesn't mistake them for placeholders. Actual placeholders can still be created with psycopg.sql.Placeholder</p> <p>Parameters:</p> <ul> <li> composed             (<code>Composed</code>)         \u2013          <p>input sql</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Composed</code>         \u2013          <p>output sql</p> </li> </ul> Source code in <code>jinja_psycopg/renderer.py</code> <pre><code>def escape_percents(composed: Composed) -&gt; Composed:\n\"\"\"\n    Replace all occurences of '%' with '%%',\n    so that psycopg doesn't mistake them for placeholders.\n    Actual placeholders can still be created with [psycopg.sql.Placeholder][]\n    Args:\n        composed: input sql\n    Returns:\n        output sql\n    \"\"\"\nnew_sequence = []\nfor token in composed:\nif isinstance(token, SQL):\ntoken = SQL(token.as_string(None).replace(\"%\", \"%%\"))\nnew_sequence.append(token)\nreturn Composed(new_sequence)\n</code></pre>"},{"location":"reference/jinja_psycopg/sql/","title":"sql","text":""},{"location":"reference/jinja_psycopg/sql/#jinja_psycopg.sql.SqlLike","title":"<code>SqlLike = Union[Composable, IntoSql]</code>  <code>module-attribute</code>","text":"<p>SQL or a type convertible to SQL</p>"},{"location":"reference/jinja_psycopg/sql/#jinja_psycopg.sql.IntoSql","title":"<code>IntoSql</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Type that has a SQL representation</p>"},{"location":"reference/jinja_psycopg/sql/#jinja_psycopg.sql.IntoSql.__sql__","title":"<code>__sql__()</code>","text":"<p>Returns:</p> <ul> <li> <code>Composable</code>         \u2013          <p>SQL representation</p> </li> </ul> Source code in <code>jinja_psycopg/sql.py</code> <pre><code>def __sql__(self) -&gt; Composable:\n\"\"\"\n    Returns:\n        SQL representation\n    \"\"\"\n...\n</code></pre>"},{"location":"reference/jinja_psycopg/sql/#jinja_psycopg.sql.sql_filter","title":"<code>sql_filter(value)</code>","text":"<p>Jinja filter for converting a string to raw SQL</p> <p>Usage: <code>{{ 'text' | sql }}</code></p> Source code in <code>jinja_psycopg/sql.py</code> <pre><code>def sql_filter(value: str) -&gt; SQL:\n\"\"\"Jinja filter for converting a string to raw SQL\n    Usage: `{{ 'text' | sql }}`\n    \"\"\"\nreturn SQL(value)\n</code></pre>"},{"location":"reference/jinja_psycopg/sql/#jinja_psycopg.sql.sql_join_filter","title":"<code>sql_join_filter(value, delimiter, attribute=None)</code>","text":"<p>Similar to jinja's join     filter, but for SQL</p> <p>Parameters:</p> <ul> <li> value             (<code>Iterable[SqlLike]</code>)         \u2013          <p>sequence to join</p> </li> <li> delimiter             (<code>str</code>)         \u2013          <p>join delimiter</p> </li> <li> attribute             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>extract objects' attribute,</p> <p>like <code>{{ users|join(', ', attribute='username') }}</code></p> </li> </ul> Source code in <code>jinja_psycopg/sql.py</code> <pre><code>def sql_join_filter(\nvalue: Iterable[SqlLike], delimiter: str, attribute: Optional[str] = None\n):\n\"\"\"\n    Similar to jinja's [join](https://jinja.palletsprojects.com/en/3.0.x/templates/#jinja-filters.join)\n        filter, but for SQL\n    Args:\n        value: sequence to join\n        delimiter: join delimiter\n        attribute: extract objects' attribute,\n            like `{{ users|join(', ', attribute='username') }}`\n    \"\"\"\nreturn SQL(delimiter).join(_preprocess_before_join(value, attribute))\n</code></pre>"}]}